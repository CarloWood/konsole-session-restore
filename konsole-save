#!/usr/bin/bash

# konsole-save
#
# Write current session state of konsole windows to JSON_FILE.
#
# Set KONSOLE_SAVE_DEBUG to write debug output. For example,
#   KONSOLE_SAVE_DEBUG=1 konsole-save
#
JSON_FILE="$HOME/.konsole_state.json"

set -o pipefail

export PATH="/usr/bin"

# Obtain lock file.
LOCKFILE="/tmp/konsole-save.lock"
exec 200>"$LOCKFILE"
flock -n 200 || exit 0

# Return success if the value looks truthy (1/true/yes/on).
is_truthy()
{
  case "${1:-}" in
    1|true|True|TRUE|yes|Yes|YES|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

# Canonicalize KONSOLE_SAVE_DEBUG.
if is_truthy "${KONSOLE_SAVE_DEBUG:-0}"; then
  KONSOLE_SAVE_DEBUG=1
else
  KONSOLE_SAVE_DEBUG=
fi

# Emit a debug message to stderr when KONSOLE_SAVE_DEBUG is enabled.
debug()
{
  [ -n "$KONSOLE_SAVE_DEBUG" ] && echo "DEBUG: $*" >&2
}

# Emit an error message to stderr.
print_error()
{
  echo "ERROR: $*" >&2
}

# Fill associative arrays with wmctrl data.
declare -A WIN_TITLES
declare -A WIN_WORKSPACES

# Normalize a window id to the "0x%08x" format used by wmctrl.
normalize_window_id()
{
  # Accepts decimal or 0xHEX, returns 0xXXXXXXXX.
  printf "0x%08x" "$(( $1 ))"
}

# Print "x y w h" for the client window geometry (xwininfo).
get_client_geometry_xywh()
{
  # Prints: "x y w h" for the client window geometry.
  local wid="$1"
  local info corner geom w h x y

  info="$(xwininfo -id "$wid" 2>/dev/null)" || return 1

  x="$(printf '%s\n' "$info" | awk -F: '/Absolute upper-left X:/ {gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); print $2; exit}')"
  y="$(printf '%s\n' "$info" | awk -F: '/Absolute upper-left Y:/ {gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); print $2; exit}')"
  w="$(printf '%s\n' "$info" | awk '/^[[:space:]]*Width:/ {print $2; exit}')"
  h="$(printf '%s\n' "$info" | awk '/^[[:space:]]*Height:/ {print $2; exit}')"

  if ! [[ "$w" =~ ^[0-9]+$ && "$h" =~ ^[0-9]+$ && "$x" =~ ^[0-9]+$ && "$y" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  printf '%s %s %s %s\n' "$x" "$y" "$w" "$h"
}

# Print "_NET_FRAME_EXTENTS" as "l r t b" (xprop).
get_frame_extents_lrtb()
{
  # Prints: "l r t b" (defaults to 0s if missing).
  local wid="$1"
  local out l r t b

  out="$(xprop -id "$wid" _NET_FRAME_EXTENTS 2>/dev/null || true)"
  if ! printf '%s\n' "$out" | grep -q '_NET_FRAME_EXTENTS'; then
    printf '0 0 0 0\n'
    return 0
  fi

  local IFS=$' \t\n'
  read -r l r t b < <(
    printf '%s\n' "$out" |
      sed -E 's/.*= *([0-9]+), *([0-9]+), *([0-9]+), *([0-9]+).*/\1 \2 \3 \4/'
  )
  if ! [[ "$l" =~ ^[0-9]+$ && "$r" =~ ^[0-9]+$ && "$t" =~ ^[0-9]+$ && "$b" =~ ^[0-9]+$ ]]; then
    printf '0 0 0 0\n'
    return 0
  fi

  printf '%s %s %s %s\n' "$l" "$r" "$t" "$b"
}

# Print "x y w h" for the outer window geometry (client + frame extents).
get_outer_geometry_xywh()
{
  # Prints: "x y w h" for the outer (frame-inclusive) geometry.
  local wid="$1"
  local cx cy cw ch l r t b

  read -r cx cy cw ch < <(get_client_geometry_xywh "$wid") || return 1
  read -r l r t b < <(get_frame_extents_lrtb "$wid") || return 1

  # We need to store the size of the CLIENT window(?!?), because that is what wmctrl -e expects.
  printf '%s %s %s %s\n' \
    "$((cx - l))" \
    "$((cy - t))" \
    "$((cw))" \
    "$((ch))"
}

wmctrl_out="$(wmctrl -l -x 2>&1)"; wmctrl_ec=$?
if [ $wmctrl_ec -ne 0 ]; then
  debug "wmctrl -l -x failed (exit=$wmctrl_ec): $wmctrl_out"
  wmctrl_out=""
fi

while read -r winid workspace host class title; do
  norm_id=$(normalize_window_id "$winid")
  WIN_TITLES["$norm_id"]="$title"
  WIN_WORKSPACES["$norm_id"]="$workspace"
done < <(printf '%s\n' "$wmctrl_out" | grep 'konsole.konsole')

qdbus_list="$(qdbus 2>&1)"; qdbus_ec=$?
if [ $qdbus_ec -ne 0 ]; then
  debug "qdbus failed (exit=$qdbus_ec): $qdbus_list"
  exit 1
fi

SERVICE="$(printf '%s\n' "$qdbus_list" | awk '{$1=$1;print}' | grep org.kde.konsole | head -n 1)"
[ -z "$SERVICE" ] && { debug "No org.kde.konsole DBus service found."; exit 1; }

debug "SERVICE=\"${SERVICE}\""

echo "[" > "$JSON_FILE"

windows=$(qdbus "$SERVICE" | grep -E '^/Windows/[0-9]+$')
if [ -n "$KONSOLE_SAVE_DEBUG" ]; then
  echo -n "windows=\"" >&2
  echo -n ${windows} | xargs echo -n >&2
  echo "\"" >&2
fi

first_win=true
for win_path in $windows; do
  visual_order=$(qdbus "$SERVICE" "$win_path" org.kde.konsole.Window.sessionList)
  ref_session=$(echo "$visual_order" | head -n 1 | awk '{print $1}')
  if [ -n "$KONSOLE_SAVE_DEBUG" ]; then
    echo >&2
    echo -n "$win_path : visual_order=\"" >&2
    echo -n ${visual_order} | xargs echo -n >&2
    echo "\", ref_session=${ref_session}" >&2
  fi
  [ -z "$ref_session" ] && continue

  ref_pid=$(qdbus "$SERVICE" "/Sessions/$ref_session" org.kde.konsole.Session.processId)
  wid_dec=$(grep -z '^WINDOWID=' "/proc/$ref_pid/environ" | cut -z -d= -f2 | xargs -0 echo)
  debug "$win_path : ref_pid=${ref_pid}, wid_dec=${wid_dec}"
  [ -z "$wid_dec" ] && continue
  wid_hex=$(normalize_window_id "$wid_dec")

  # If the X11 window id is not present in wmctrl output, the window is not mapped/managed.
  if [ -z "${WIN_TITLES[$wid_hex]+x}" ]; then
    debug "$win_path : UNMAPPED window ${wid_hex}! Ignoring."
    continue
  fi
  debug "$win_path : wid_hex=${wid_hex}"

  # Lookup data from our associative arrays.
  title="${WIN_TITLES[$wid_hex]}"
  workspace="${WIN_WORKSPACES[$wid_hex]}"

  # Obtain outer geometry (client + _NET_FRAME_EXTENTS).
  if ! read -r x y w h < <(get_outer_geometry_xywh "$wid_hex"); then
    debug "$win_path : Failed to read geometry for ${wid_hex}! Ignoring."
    continue
  fi
  debug "$win_path : geom=${x},${y},${w},${h} workspace=${workspace}"

  # Build sessions CWD list.
  # We gather them into an array first to pass to jq safely.
  session_cwds=()
  session_profiles=()
  for s_id in $visual_order; do
    # Obtain current working directory.
    s_pid=$(qdbus "$SERVICE" "/Sessions/$s_id" org.kde.konsole.Session.processId)
    s_cwd=$(readlink -f "/proc/$s_pid/cwd" 2>/dev/null)
    session_cwds+=("$s_cwd")

    # Obtain profile name.
    s_profile=$(qdbus "$SERVICE" "/Sessions/$s_id" org.kde.konsole.Session.profile)
    session_profiles+=("$s_profile")
  done
  if [ -n "$KONSOLE_SAVE_DEBUG" ]; then
    echo -n "$win_path : session_cwds=[ " >&2
    printf '"%s" ' "${session_cwds[@]}" >&2
    echo "]" >&2
    echo -n "$win_path : session_profiles=[ " >&2
    printf '"%s" ' "${session_profiles[@]}" >&2
    echo "]" >&2
  fi

  [ "$first_win" = false ] && echo "," >> "$JSON_FILE"
  
  # Use jq to write a properly escaped JSON object.
  # This handles quotes in titles and paths automatically.
  cwds_json=$(printf '%s\n' "${session_cwds[@]}" | jq -R . | jq -s .)
  debug "$win_path : cwds_json='$cwds_json'"
  profiles_json=$(printf '%s\n' "${session_profiles[@]}" | jq -R . | jq -s .)
  debug "$win_path : profiles_json='$profiles_json'"

  debug "$win_path : appending to \"$JSON_FILE\"."
  jq -n \
    --arg wid "$wid_hex" \
    --arg title "$title" \
    --arg x "$x" --arg y "$y" --arg w "$w" --arg h "$h" \
    --arg ws "$workspace" \
    --argjson cwds "$cwds_json" \
    --argjson profiles "$profiles_json" \
    '{
      window_id: $wid,
      title: $title,
      x: ($x|tonumber),
      y: ($y|tonumber),
      w: ($w|tonumber),
      h: ($h|tonumber),
      workspace: ($ws|tonumber),
      sessions: [
        range(0; ($cwds|length)) as $i
        | { cwd: $cwds[$i], profile: $profiles[$i] }
      ]
    }' >> "$JSON_FILE"

  first_win=false
done

echo "]" >> "$JSON_FILE"
