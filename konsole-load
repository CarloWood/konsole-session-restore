#!/bin/bash

JSON_FILE="$HOME/.konsole_state.json"
[ ! -f "$JSON_FILE" ] && { echo "JSON file not found"; exit 0; }

set -o pipefail

TABS_FILE="/tmp/restore-tabs.txt"

export PATH="/usr/bin"
SELF_PATH="$(readlink -f "${BASH_SOURCE[0]}")"

is_truthy()
{
  case "${1:-}" in
    1|true|True|TRUE|yes|Yes|YES|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

running_under_systemd()
{
  # systemd sets INVOCATION_ID for unit processes.
  [ -n "${INVOCATION_ID:-}" ]
}

# Set KONSOLE_LOAD_DEBUG=1 to avoid silencing deferred output.
KONSOLE_LOAD_DEBUG="${KONSOLE_LOAD_DEBUG:-0}"

write_windowids_file()
{
  local out i
  out="$(mktemp /tmp/konsole-load-windowids.XXXXXX)"
  {
    printf 'declare -a WINDOWIDS\n'
    for (( i=0; i<$NUM_WINDOWS; i++ )); do
      [ -n "${WINDOWIDS[$i]:-}" ] || continue
      printf 'WINDOWIDS[%d]=%q\n' "$i" "${WINDOWIDS[$i]}"
    done
  } >"$out"
  printf '%s\n' "$out"
}

run_deferred_apply()
{
  local windowids_file="$1"

  if running_under_systemd && command -v systemd-run >/dev/null 2>&1; then
    # Start a transient unit so the deferred work does not live in this oneshot
    # unit's control group (otherwise systemd may kill it / warn about leftovers).
    local unit="konsole-load-apply-$$-$(date +%s)"
    local -a cmd=(
      systemd-run
      --user
      --quiet
      --collect
      --unit="$unit"
      # Pass GUI env through explicitly; systemd-run units do not automatically
      # inherit this from the calling process in a reliable way.
#      --setenv=DISPLAY="${DISPLAY:-}"
#      --setenv=XAUTHORITY="${XAUTHORITY:-}"
#      --setenv=DBUS_SESSION_BUS_ADDRESS="${DBUS_SESSION_BUS_ADDRESS:-}"
      --setenv=KONSOLE_LOAD_MODE=apply
      --setenv=KONSOLE_LOAD_WINDOWIDS_FILE="$windowids_file"
    )

    if is_truthy "$KONSOLE_LOAD_DEBUG"; then
      cmd+=(--setenv=KONSOLE_LOAD_DEBUG=1)
    else
      # Keep default behavior quiet; still keep stderr in the journal in case of errors.
      cmd+=(--property=StandardOutput=null --property=StandardError=journal)
    fi

    "${cmd[@]}" "$SELF_PATH"
    return $?
  fi

  # Fallback for non-systemd execution: keep old behavior (best-effort).
  if is_truthy "$KONSOLE_LOAD_DEBUG"; then
    KONSOLE_LOAD_MODE=apply KONSOLE_LOAD_WINDOWIDS_FILE="$windowids_file" "$SELF_PATH" &
  else
    KONSOLE_LOAD_MODE=apply KONSOLE_LOAD_WINDOWIDS_FILE="$windowids_file" "$SELF_PATH" >/dev/null 2>&1 &
  fi
}

# Initialize associative arrays.
declare -A WIN_TITLES
declare -A WIN_GEOM_X
declare -A WIN_GEOM_Y
declare -A WIN_GEOM_W
declare -A WIN_GEOM_H
declare -A WIN_WORKSPACES
declare -A WIN_CWDS                     # Stores paths separated by newlines.
declare -A WIN_PROFILES

# Use jq to build the associative array assignments.
eval "$(
  jq -r '
    to_entries[]
    | select(.value != null)
    | "WIN_TITLES[\"\(.key)\"]=\(.value.title // "" | @sh); " +
      "WIN_GEOM_X[\"\(.key)\"]=\("\(.value.x)" | @sh); " +
      "WIN_GEOM_Y[\"\(.key)\"]=\("\(.value.y)" | @sh); " +
      "WIN_GEOM_W[\"\(.key)\"]=\("\(.value.w)" | @sh); " +
      "WIN_GEOM_H[\"\(.key)\"]=\("\(.value.h)" | @sh); " +
      "WIN_WORKSPACES[\"\(.key)\"]=\(.value.workspace // 0 | @sh); " +
      "WIN_CWDS[\"\(.key)\"]=\((.value.sessions // [] | map(.cwd // "") | join("\n")) | @sh); " +
      "WIN_PROFILES[\"\(.key)\"]=\((.value.sessions // [] | map(.profile // "Profile 1") | join("\n")) | @sh); "
  ' "$JSON_FILE"
)"

NUM_WINDOWS=${#WIN_TITLES[@]}

normalize_window_id()
{
  # Accepts decimal or 0xHEX, returns 0xXXXXXXXX.
  printf "0x%08x" "$(( $1 ))"
}

wait_wmctrl_ready()
{
  # wmctrl requires an EWMH-capable window manager to set _NET_CLIENT_LIST on the root window.
  # When konsole-load is started early (e.g. from .xinitrc), wmctrl can fail until the WM is up.
  local tries="${WAIT_WMCTRL_TRIES:-600}"   # 600 * 0.05s = 30s
  local sleep_s="${WAIT_WMCTRL_SLEEP:-0.05}"
  local attempt=0

  while (( attempt < tries )); do
    wmctrl -lx >/dev/null 2>&1 && return 0
    sleep "$sleep_s"
    ((attempt++))
  done

  return 1
}

desktop_size()
{
  # Usage: desktop_size <desktop_index>
  # Output: "<width> <height>" (empty if unknown)
  local desktop="$1"

  wmctrl -d 2>/dev/null | awk -v d="$desktop" '
    $1 == d {
      for (i = 1; i <= NF; i++) {
        if ($i == "DG:") {
          split($(i+1), a, "x")
          print a[1], a[2]
          exit
        }
      }
    }
  '
}

wait_desktop_size()
{
  # Usage: wait_desktop_size <desktop_index> <x> <y>
  # Wait up to 10 seconds until x < width and y < height for that desktop (wmctrl -d DG:).
  local desktop="$1"
  local x="$2"
  local y="$3"

  local deadline=$((SECONDS + 10))
  local width height

  while (( SECONDS < deadline )); do
    read -r width height <<<"$(desktop_size "$desktop")"

    if [[ "$width" =~ ^[0-9]+$ && "$height" =~ ^[0-9]+$ ]]; then
      if (( x < width && y < height )); then
        echo "wait_desktop_size: workspace $desktop has size ${width}x${height}; requested position: $x $y."
        return 0
      fi
    fi

    sleep 0.2
  done

  read -r width height <<<"$(desktop_size "$desktop")"
  if [[ "$width" =~ ^[0-9]+$ && "$height" =~ ^[0-9]+$ ]]; then
    echo "Timed out waiting for desktop $desktop to reach full size (need x<$width y<$height; have x=$x y=$y)." >&2
  else
    echo "Timed out waiting for desktop $desktop geometry to become available (have x=$x y=$y)." >&2
  fi
  return 1
}

list_konsole_wids()
{
  # Output hex window IDs (like 0x03e00007), one per line.
  # Do not depend on a running WM: xdotool queries X11 directly.
  local ids id
  ids="$(
    {
      xdotool search --class 'konsole|Konsole|org\\.kde\\.konsole' 2>/dev/null || true
      xdotool search --classname 'konsole|Konsole|org\\.kde\\.konsole' 2>/dev/null || true
    } | sed '/^$/d' | sort -n -u
  )"

  [ -z "$ids" ] && return 0

  while read -r id; do
    [ -z "$id" ] && continue
    printf '%s\n' "$(normalize_window_id "$id")"
  done <<<"$ids"
}

wait_new_konsole_wid()
{
  # Wait for exactly one new Konsole window compared to the snapshot given on stdin.
  local tmp_before tmp_after
  local new_wids

  tmp_before=$(mktemp)
  tmp_after=$(mktemp)

  cat >"$tmp_before"

  for _ in {1..50}; do
    if ! list_konsole_wids | sort -u >"$tmp_after"; then
      echo 'wait_new_konsole_wid: list_konsole_wids failed.' >&2
      sleep 0.05
      continue
    fi

    # Set difference: after \ before.
    new_wids=$(comm -13 "$tmp_before" "$tmp_after")

    # If exactly one new window: return it.
    if [ "$(printf '%s\n' "$new_wids" | sed '/^$/d' | wc -l)" -eq 1 ]; then
      echo "wait_new_konsole_wid: success; new_wids=\"$new_wids\"." >&2
      printf '%s\n' "$new_wids"
      rm -f "$tmp_before" "$tmp_after"
      return 0
    else
      echo "wait_new_konsole_wid: ignoring because new_wids=\"$new_wids\"." >&2
    fi

    sleep 0.2
  done

  echo "wait_new_konsole_wid: timed out. new_wids=\"$new_wids\", tmp_before=\"$(cat $tmp_before)\", tmp_after=\"$(cat $tmp_after)\"." >&2
  rm -f "$tmp_before" "$tmp_after"
  return 1
}

apply_window_properties()
{
  local i wid

  wait_wmctrl_ready || {
    echo "wmctrl is not ready (no EWMH window manager yet?)" >&2
    return 1
  }

  for (( i=0; i<$NUM_WINDOWS; i++ )); do
    wid="${WINDOWIDS[$i]}"
    [ -z "$wid" ] && continue

    echo "apply_window_properties: processing $wid"

    # Wait for the size of the root window to be large enough (in case more than one monitor is being used).
    wait_desktop_size "${WIN_WORKSPACES[$i]}" "${WIN_GEOM_X[$i]}" "${WIN_GEOM_Y[$i]}" || return 1

    # Activate the window in case it isn't (see https://bugs.kde.org/show_bug.cgi?id=502075).
    echo "Calling 'wmctrl -ia \"$wid\"'."
    wmctrl -ia "$wid"

    # Move window to the correct workspace.
    echo "Calling 'wmctrl -ir \"$wid\" -t \"${WIN_WORKSPACES[$i]}\"'."
    wmctrl -ir "$wid" -t "${WIN_WORKSPACES[$i]}" || true

    # Fix the geometry.
    echo "Calling 'wmctrl -ir \"$wid\" -e \"0,${WIN_GEOM_X[$i]},${WIN_GEOM_Y[$i]},${WIN_GEOM_W[$i]},${WIN_GEOM_H[$i]}\""
    wmctrl -ir "$wid" -e "0,${WIN_GEOM_X[$i]},${WIN_GEOM_Y[$i]},${WIN_GEOM_W[$i]},${WIN_GEOM_H[$i]}" || true

    echo "Resulting geometry 1:"
    wmctrl -lGx | grep "^$wid" || true

  done
}

declare -a WINDOWIDS

if [ "${KONSOLE_LOAD_MODE:-}" = "apply" ]; then
  if [ -z "${KONSOLE_LOAD_WINDOWIDS_FILE:-}" ] || [ ! -f "${KONSOLE_LOAD_WINDOWIDS_FILE:-}" ]; then
    echo "KONSOLE_LOAD_MODE=apply requires KONSOLE_LOAD_WINDOWIDS_FILE to exist." >&2
    exit 1
  fi

  # shellcheck source=/dev/null
  source "$KONSOLE_LOAD_WINDOWIDS_FILE"
  rm -f "$KONSOLE_LOAD_WINDOWIDS_FILE" || true
  apply_window_properties || exit 1
  exit 0
fi

for (( i=0; i<$NUM_WINDOWS; i++ )); do
  echo -n "Processing window $i "
  echo -n > "$TABS_FILE-$i"
  readarray -t TAB_CWDS <<< "${WIN_CWDS[$i]}"
  readarray -t TAB_PROFILES <<< "${WIN_PROFILES[$i]}"
  NUM_TABS=${#TAB_CWDS[@]}
  for (( t=0; t<$NUM_TABS; t++ )); do
    echo "workdir: ${TAB_CWDS[$t]} ;; profile: ${TAB_PROFILES[$t]}" >> "$TABS_FILE-$i"
  done
  before=$(list_konsole_wids | sort -u)
  echo -n "(window ids before: $(echo "$before" | xargs echo)) : "
  setsid konsole --tabs-from-file "$TABS_FILE-$i" -e true </dev/null >/dev/null 2>&1 &
  WINDOWID=$(printf '%s\n' "$before" | wait_new_konsole_wid) || {
    echo "Failed to detect new Konsole window." >&2
    exit 1
  }
  WINDOWIDS[$i]="$WINDOWID"
  echo "$WINDOWID"
  # Clean up.
  rm "$TABS_FILE-$i"
done

# If a WM is already up, apply immediately. Otherwise, defer until it is.
if wmctrl -lx >/dev/null 2>&1; then
  apply_window_properties || exit 1
else
  windowids_file="$(write_windowids_file)"
  run_deferred_apply "$windowids_file" || exit 1
fi
