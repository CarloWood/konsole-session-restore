#!/bin/bash

JSON_FILE="$HOME/.konsole_state.json"
[ ! -f "$JSON_FILE" ] && { echo "JSON file not found"; exit 0; }

set -o pipefail

TABS_FILE="/tmp/restore-tabs.txt"

export PATH="/usr/bin"

# Initialize associative arrays.
declare -A WIN_TITLES
declare -A WIN_GEOM_X
declare -A WIN_GEOM_Y
declare -A WIN_GEOM_W
declare -A WIN_GEOM_H
declare -A WIN_WORKSPACES
declare -A WIN_CWDS                     # Stores paths separated by newlines.
declare -A WIN_PROFILES

# Use jq to build the associative array assignments.
eval "$(
  jq -r '
    to_entries[]
    | select(.value != null)
    | "WIN_TITLES[\"\(.key)\"]=\(.value.title // "" | @sh); " +
      "WIN_GEOM_X[\"\(.key)\"]=\("\(.value.x)" | @sh); " +
      "WIN_GEOM_Y[\"\(.key)\"]=\("\(.value.y)" | @sh); " +
      "WIN_GEOM_W[\"\(.key)\"]=\("\(.value.w)" | @sh); " +
      "WIN_GEOM_H[\"\(.key)\"]=\("\(.value.h)" | @sh); " +
      "WIN_WORKSPACES[\"\(.key)\"]=\(.value.workspace // 0 | @sh); " +
      "WIN_CWDS[\"\(.key)\"]=\((.value.sessions // [] | map(.cwd // "") | join("\n")) | @sh); " +
      "WIN_PROFILES[\"\(.key)\"]=\((.value.sessions // [] | map(.profile // "Profile 1") | join("\n")) | @sh); "
  ' "$JSON_FILE"
)"

NUM_WINDOWS=${#WIN_TITLES[@]}

normalize_window_id()
{
  # Accepts decimal or 0xHEX, returns 0xXXXXXXXX.
  printf "0x%08x" "$(( $1 ))"
}

wait_wmctrl_ready()
{
  # wmctrl requires an EWMH-capable window manager to set _NET_CLIENT_LIST on the root window.
  # When konsole-load is started early (e.g. from .xinitrc), wmctrl can fail until the WM is up.
  local tries="${WAIT_WMCTRL_TRIES:-600}"   # 600 * 0.05s = 30s
  local sleep_s="${WAIT_WMCTRL_SLEEP:-0.05}"
  local attempt=0

  while (( attempt < tries )); do
    wmctrl -lx >/dev/null 2>&1 && return 0
    sleep "$sleep_s"
    ((attempt++))
  done

  return 1
}

list_konsole_wids()
{
  # Output hex window IDs (like 0x03e00007), one per line.
  # Do not depend on a running WM: xdotool queries X11 directly.
  local ids id
  ids="$(
    {
      xdotool search --class 'konsole|Konsole|org\\.kde\\.konsole' 2>/dev/null || true
      xdotool search --classname 'konsole|Konsole|org\\.kde\\.konsole' 2>/dev/null || true
    } | sed '/^$/d' | sort -n -u
  )"

  [ -z "$ids" ] && return 0

  while read -r id; do
    [ -z "$id" ] && continue
    printf '%s\n' "$(normalize_window_id "$id")"
  done <<<"$ids"
}

wait_new_konsole_wid()
{
  # Wait for exactly one new Konsole window compared to the snapshot given on stdin.
  local tmp_before tmp_after
  local new_wids

  tmp_before=$(mktemp)
  tmp_after=$(mktemp)

  cat >"$tmp_before"

  for _ in {1..200}; do
    if ! list_konsole_wids | sort -u >"$tmp_after"; then
      sleep 0.05
      continue
    fi

    # Set difference: after \ before.
    new_wids=$(comm -13 "$tmp_before" "$tmp_after")

    # If exactly one new window: return it.
    if [ "$(printf '%s\n' "$new_wids" | sed '/^$/d' | wc -l)" -eq 1 ]; then
      printf '%s\n' "$new_wids"
      rm -f "$tmp_before" "$tmp_after"
      return 0
    fi

    sleep 0.05
  done

  rm -f "$tmp_before" "$tmp_after"
  return 1
}

apply_window_properties()
{
  local i wid

  wait_wmctrl_ready || {
    echo "wmctrl is not ready (no EWMH window manager yet?)" >&2
    return 1
  }

  for (( i=0; i<$NUM_WINDOWS; i++ )); do
    wid="${WINDOWIDS[$i]}"
    [ -z "$wid" ] && continue

    # Activate the window in case it isn't (see https://bugs.kde.org/show_bug.cgi?id=502075).
    wmctrl -ia "$wid"

    # Move window to the correct workspace.
    wmctrl -ir "$wid" -t "${WIN_WORKSPACES[$i]}" || true

    # Fix the geometry.
    wmctrl -ir "$wid" -e "0,${WIN_GEOM_X[$i]},${WIN_GEOM_Y[$i]},${WIN_GEOM_W[$i]},${WIN_GEOM_H[$i]}" || true
  done
}

declare -a WINDOWIDS

for (( i=0; i<$NUM_WINDOWS; i++ )); do
  echo -n "Processing window $i "
  echo -n > "$TABS_FILE-$i"
  readarray -t TAB_CWDS <<< "${WIN_CWDS[$i]}"
  readarray -t TAB_PROFILES <<< "${WIN_PROFILES[$i]}"
  NUM_TABS=${#TAB_CWDS[@]}
  for (( t=0; t<$NUM_TABS; t++ )); do
    echo "workdir: ${TAB_CWDS[$t]} ;; profile: ${TAB_PROFILES[$t]}" >> "$TABS_FILE-$i"
  done
  before=$(list_konsole_wids | sort -u)
  echo -n "(window ids before: $(echo "$before" | xargs echo)) : "
  setsid konsole --tabs-from-file "$TABS_FILE-$i" -e sleep 0.2 </dev/null >/dev/null 2>&1 &
  WINDOWID=$(printf '%s\n' "$before" | wait_new_konsole_wid) || {
    echo "Failed to detect new Konsole window." >&2
    exit 1
  }
  WINDOWIDS[$i]="$WINDOWID"
  echo "$WINDOWID"
  # Clean up.
  rm "$TABS_FILE-$i"
done

# If a WM is already up, apply immediately. Otherwise, defer until it is.
if wmctrl -lx >/dev/null 2>&1; then
  apply_window_properties || exit 1
else
  apply_window_properties >/dev/null 2>&1 &
fi
